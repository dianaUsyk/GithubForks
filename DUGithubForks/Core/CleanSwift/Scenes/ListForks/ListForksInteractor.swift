//
//  ListForksInteractor.swift
//  DUGithubForks
//
//  Created by Di on 30.11.2017.
//  Copyright (c) 2017 Di. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListForksBusinessLogic {
    func updateHeaderOnLoad(request: ListForks.RepoHeader.Request)
    func updateForks(request: ListForks.FetchForks.Request)
    func selectFork(request: ListForks.SelectFork.Request)

    func canLoadNextPage() -> Bool
}

protocol ListForksDataStore {
    var repository: FetchedRepository! { get set }
    var selectedRepository: FetchedRepository? { get set }
}

class ListForksInteractor: ListForksBusinessLogic, ListForksDataStore {
    var presenter: ListForksPresentationLogic?
    lazy var worker: RepositoryWorker = {
        return RepositoryWorker()
    }()
    var repository: FetchedRepository!
    var selectedRepository: FetchedRepository?

    // MARK: Do something

    func updateHeaderOnLoad(request: ListForks.RepoHeader.Request) {
        let response = ListForks.RepoHeader.Response(repository: repository)
        presenter?.presentHeaderOnLoad(response: response)
    }

    func updateForks(request: ListForks.FetchForks.Request) {
        let cursor = repository.forks.pageInfo.endCursor
        worker.fetchRepositoryForks(with: repository.name, ownerName: repository.owner.login, forksCount: request.forksCount, after: cursor, completion: { [weak self] (result) in
            
            let response: ListForks.FetchForks.Response!
            
            switch result {
            case let .failure(error):
                response = ListForks.FetchForks.Response(repository: nil, errorMessage: error.localizedDescription)
            case let .success(some):
                var nodes = self?.repository.forks.nodes ?? []
                if let nextNodes = some.forks.nodes {
                    nodes.append(contentsOf: nextNodes)
                }
                self?.repository = some
                self?.repository.forks.nodes = nodes
                response = ListForks.FetchForks.Response(repository: some, errorMessage: nil)
            }
            
            self?.presenter?.presentForks(response: response)
        })
    }
    
    func selectFork(request: ListForks.SelectFork.Request) {
        guard let node = repository.forks.nodes?[request.index] else {
            return
        }
        let selectedSnapshotRepository = FetchedRepository(snapshot: node.snapshot)
        selectedRepository = selectedSnapshotRepository
        
        let response = ListForks.SelectFork.Response(repository: selectedSnapshotRepository)
        presenter?.presentSelectedFork(response: response)
    }
    
    func canLoadNextPage() -> Bool {
        return repository.forks.pageInfo.hasNextPage
    }
}
